# -*- coding: utf-8 -*-
"""NewRecommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wl_ucFJZMOgEB79Ci8NqhZhfeN5WCHi8
"""

!pip install fuzzywuzzy[speedup]

import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import mean_squared_error
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from sklearn.metrics import precision_score, recall_score

from sklearn.feature_extraction.text import TfidfVectorizer
from fuzzywuzzy import process

movies = pd.read_csv("dataset.csv")
movies['genre'].fillna('', inplace=True)
movies['overview'].fillna('', inplace=True)

movies['tags'] = movies['overview'] + ' ' + movies['genre']

movies.drop(columns=["overview", "genre"])

movies.head()

tfidf = TfidfVectorizer(stop_words='english', max_features=10000)
tfidf_matrix = tfidf.fit_transform(movies['tags'])
tfidf_matrix.shape

cv = CountVectorizer(max_features=10000, stop_words="english")
vector = cv.fit_transform(movies["tags"])
vector.shape

similarity_tfidf = cosine_similarity(tfidf_matrix)
similarity_tfidf

similarity = cosine_similarity(vector)
similarity

# KMeans Clustering
num_clusters = 5  # Set the number of clusters you want
kmeans = KMeans(n_clusters=num_clusters, random_state=42)
movies['cluster'] = kmeans.fit_predict(similarity_tfidf)

# Perform PCA to reduce dimensionality for visualization
pca = PCA(n_components=2)
pca_components = pca.fit_transform(tfidf_matrix.toarray())  # Transforming the matrix into 2D components

# Create a DataFrame for easy plotting
pca_df = pd.DataFrame(pca_components, columns=['PCA1', 'PCA2'])
pca_df['title'] = movies['title']
pca_df['cluster'] = movies['cluster']

# Plot the movies in 2D space based on PCA components
plt.figure(figsize=(12, 10))

# Use different colors for each cluster
for cluster in range(num_clusters):
    cluster_data = pca_df[pca_df['cluster'] == cluster]
    plt.scatter(cluster_data['PCA1'], cluster_data['PCA2'], label=f'Cluster {cluster}', s=60, alpha=0.7)

plt.title('Movie Groups Based on Cosine Similarity (PCA & KMeans Clustering)')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.legend()
plt.show()

num_clusters = 5  # Set the number of clusters you want
kmeans = KMeans(n_clusters=num_clusters, random_state=42)
movies['cluster'] = kmeans.fit_predict(similarity)

# Perform PCA to reduce the dimensionality of the feature vectors to 2D
pca = PCA(n_components=2)
pca_components = pca.fit_transform(vector)

# Create a DataFrame for easy plotting
pca_df = pd.DataFrame(pca_components, columns=['PCA1', 'PCA2'])
pca_df['title'] = movies['title']
pca_df['cluster'] = movies['cluster']

# Plot the movies in 2D space based on PCA components
plt.figure(figsize=(12, 10))

# Use different colors for each cluster
for cluster in range(num_clusters):
    cluster_data = pca_df[pca_df['cluster'] == cluster]
    plt.scatter(cluster_data['PCA1'], cluster_data['PCA2'], label=f'Cluster {cluster}', s=60, alpha=0.7)

plt.title('Movie Groups Based on Cosine Similarity (PCA & KMeans Clustering)')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.legend()
plt.show()

def get_closest_movie(user_input, movie_titles):
    match, score = process.extractOne(user_input, movie_titles)
    if score > 80:  # Adjust this threshold as needed
        return match
    else:
        return None

def recommend_movies_tfidf(*movie_names):
    recommendations = {}

    for movie_name in movie_names:
        # Get the closest movie name using fuzzy matching
        closest_movie = get_closest_movie(movie_name, movies['title'].tolist())

        if closest_movie:
            try:
                # Find the index of the given movie
                movie_idx = movies[movies['title'] == closest_movie].index[0]

                # Retrieve similarity scores for the movie
                sim_scores = list(enumerate(similarity_tfidf[movie_idx]))

                # Sort the movies by similarity scores in descending order
                sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

                # Get the indices of the top N similar movies (excluding the movie itself)
                top_similar = sim_scores[1:11]

                # Fetch the titles of the top similar movies
                recommended_titles = [movies.iloc[i[0]].title for i in top_similar]

                recommendations[movie_name] = recommended_titles

            except IndexError:
                recommendations[movie_name] = ["Movie not found. Please check the movie name."]
        else:
            recommendations[movie_name] = ["Movie not found. Please check the movie name."]

    return recommendations

def recommend_movies(*movie_names):
    recommendations = {}

    for movie_name in movie_names:
        # Get the closest movie name using fuzzy matching
        closest_movie = get_closest_movie(movie_name, movies['title'].tolist())

        if closest_movie:
            try:
                # Find the index of the given movie
                movie_idx = movies[movies['title'] == closest_movie].index[0]

                # Retrieve similarity scores for the movie
                sim_scores = list(enumerate(similarity[movie_idx]))

                # Sort the movies by similarity scores in descending order
                sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

                # Get the indices of the top N similar movies (excluding the movie itself)
                top_similar = sim_scores[1:11]

                # Fetch the titles of the top similar movies
                recommended_titles = [movies.iloc[i[0]].title for i in top_similar]

                recommendations[movie_name] = recommended_titles

            except IndexError:
                recommendations[movie_name] = ["Movie not found. Please check the movie name."]
        else:
            recommendations[movie_name] = ["Movie not found. Please check the movie name."]

    return recommendations

recommend_movies_tfidf("seven")

recommend_movies("seven")

# Function to calculate Precision and Recall for movie recommendations
def calculate_precision_recall(movie_names):
    precision_values = []
    recall_values = []

    for movie_name in movie_names:
        try:
            # Find the index of the given movie
            movie_idx = movies[movies['title'] == movie_name].index[0]

            # Retrieve similarity scores for the movie
            sim_scores = list(enumerate(similarity[movie_idx]))

            # Sort the movies by similarity scores in descending order
            sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

            # Get the indices of the top N similar movies (excluding the movie itself)
            top_similar = sim_scores[1:11]

            # Fetch the titles of the top similar movies
            recommended_titles = [movies.iloc[i[0]].title for i in top_similar]

            # Get the actual cluster of the movie
            movie_cluster = movies.iloc[movie_idx]['cluster']

            # Calculate True Positives (TP), False Positives (FP), and False Negatives (FN)
            true_positives = sum([movies[movies['title'] == title]['cluster'].values[0] == movie_cluster for title in recommended_titles])
            false_positives = len(recommended_titles) - true_positives
            false_negatives = sum([movies[movies['cluster'] == movie_cluster].shape[0] > 0 and movies[movies['title'] == title]['cluster'].values[0] != movie_cluster for title in recommended_titles])

            # Calculate Precision and Recall
            precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
            recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0

            precision_values.append(precision)
            recall_values.append(recall)

        except IndexError:
            print(f"Movie '{movie_name}' not found.")

    # Calculate the average Precision and Recall across all movies
    avg_precision = sum(precision_values) / len(precision_values) if precision_values else 0
    avg_recall = sum(recall_values) / len(recall_values) if recall_values else 0

    return avg_precision, avg_recall

# Evaluate Precision and Recall for some example movies (change these movie names as per your dataset)
avg_precision, avg_recall = calculate_precision_recall(["Star Wars", "Wonder Woman"])
print(f"Average Precision: {avg_precision:.4f}")
print(f"Average Recall: {avg_recall:.4f}")

import random

def recommend_random_movies_from_cluster(movie_name):
    # Get the closest movie name using fuzzy matching
    closest_movie = get_closest_movie(movie_name, movies['title'].tolist())

    if closest_movie:
        try:
            # Find the index of the given movie
            movie_idx = movies[movies['title'] == closest_movie].index[0]

            # Retrieve the cluster of the movie
            movie_cluster = movies.iloc[movie_idx]['cluster']  # Ensure the column name matches

            # Get all movies in the same cluster, excluding the input movie
            cluster_movies = movies[movies['cluster'] == movie_cluster]
            cluster_movies = cluster_movies[cluster_movies['title'] != closest_movie]

            # Randomly select up to 10 movies
            random_recommendations = cluster_movies['title'].sample(
                n=min(10, len(cluster_movies)), random_state=42
            ).tolist()

            return {
                "Input Movie": closest_movie,
                "Random Cluster Recommendations": random_recommendations,
            }

        except ValueError:
            return {"Error": "Not enough movies in the cluster to recommend 10."}

    else:
        return {"Error": "Movie not found. Please check the movie name."}

recommend_random_movies_from_cluster("Star Wars")

