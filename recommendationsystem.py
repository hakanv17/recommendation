# -*- coding: utf-8 -*-
"""RecommendationSystem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fiCA_-kd31wnbTf7OvW9D_mat6gNgd1-
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MultiLabelBinarizer

unames = ["user_id", "gender", "age", "occupation", "zip"]
users = pd.read_table("users.dat", sep="::",
                     header=None, names=unames, engine="python")
new_users = users.drop(columns=["zip","occupation"])

new_users

rnames = ["user_id", "movie_id", "rating", "timestamp"]
ratings = pd.read_table("ratings.dat", sep="::",
                       header=None, names=rnames, engine="python")

new_ratings = ratings.drop(columns=["timestamp"])
new_ratings

mnames = ["movie_id", "title", "genres"]
movies = pd.read_table("movies.dat", sep="::",
                      header=None, names=mnames, engine="python")

movies

data = pd.merge(pd.merge(new_ratings, new_users), movies)

data

# Create a User-Item Matrix (users as rows, movies as columns)
user_item_matrix = data.pivot_table(index='user_id', columns='movie_id', values='rating')

# Fill missing values with 0 (indicating unrated movies)
user_item_matrix = user_item_matrix.fillna(0)

# Split the data into train and test sets
train_data, test_data = train_test_split(data, test_size=0.005, random_state=42)

# Create training user-item matrix
train_user_item_matrix = train_data.pivot_table(index='user_id', columns='movie_id', values='rating').fillna(0)

# Create testing user-item matrix
test_user_item_matrix = test_data.pivot_table(index='user_id', columns='movie_id', values='rating').fillna(0)

# Calculate cosine similarity between users based on their ratings
user_similarity = cosine_similarity(user_item_matrix)

# Use KMeans clustering to group users based on their similarity
n_clusters = 5  # You can choose any number of clusters
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
user_groups = kmeans.fit_predict(user_similarity)

# Add the user group to the users dataframe
new_users['user_group'] = user_groups

# Display user groups
print("User Groups (Clustered based on ratings):")
new_users.head(10)

# Convert genre lists to binary vectors using MultiLabelBinarizer
mlb = MultiLabelBinarizer()
genre_vectors = mlb.fit_transform(movies['genres'])

# Compute cosine similarity between movies based on their genre vectors
movie_similarity = cosine_similarity(genre_vectors)

# Create a function to get movie recommendations based on content similarity
def content_based_recommendation(movie_id, top_n=5):
    # Get the index of the movie in the movies dataset
    movie_idx = movies[movies['movie_id'] == movie_id].index[0]

    # Get the similarity scores for the given movie
    similarity_scores = movie_similarity[movie_idx]

    # Get indices of the top N most similar movies (excluding the movie itself)
    similar_movies_idx = similarity_scores.argsort()[-top_n-1:-1][::-1]

    # Get the movie titles for the top N recommendations
    similar_movies = movies.iloc[similar_movies_idx]['title'].values
    return similar_movies

# Example: Get top 5 content-based recommendations for movie ID 1
print("Content-Based Recommendations for Movie 1:")
print(content_based_recommendation(1, top_n=5))

# Function to recommend movies for a specific user
def recommend_movies(user_id, top_n=5):
    # Get the group of the given user
    user_group = new_users[new_users['user_id'] == user_id]['user_group'].values[0]

    # Get other users in the same group
    similar_users = new_users[new_users['user_group'] == user_group]

    # Get the movies that these users have rated highly in the training data
    similar_users_ratings = train_data[train_data['user_id'].isin(similar_users['user_id'])]

    # Get the movies with the highest average rating from similar users
    top_rated_movies = similar_users_ratings.groupby('movie_id')['rating'].mean().sort_values(ascending=False).head(top_n)

    # Recommend the top-rated movies to the user
    recommended_movie_titles = movies[movies['movie_id'].isin(top_rated_movies.index)]['title'].values
    return recommended_movie_titles

# Example: Recommend movies for user with ID 1
user_id_to_recommend = 1
print("Recommended Movies:")
print(recommend_movies(user_id_to_recommend, top_n=10))

from sklearn.metrics import mean_squared_error

# Get the actual ratings from the test set
actual_ratings = test_data[['user_id', 'movie_id', 'rating']]

# Predict ratings using your recommendation function (here you might need to use a model to predict ratings, for now we're using the training data as a baseline)
# For simplicity, let’s assume predicted ratings are the ones from the training set
predicted_ratings = test_data[['user_id', 'movie_id']].copy()

# For each user-movie pair in the test set, we’ll use the training data to predict the rating (could be the mean rating of the movie)
predicted_ratings['rating'] = predicted_ratings['movie_id'].apply(
    lambda x: train_data[train_data['movie_id'] == x]['rating'].mean() if len(train_data[train_data['movie_id'] == x]) > 0 else 0
)

# Calculate the Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse = mean_squared_error(actual_ratings['rating'], predicted_ratings['rating'])
rmse = np.sqrt(mse)

print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

